// __tests__/lib/actions/{{name}}.test.ts
/**
 * Server Action Tests for {{Name}}
 *
 * Uses queue-based mock pattern for Drizzle ORM.
 * See KNOWLEDGE.md for detailed pattern explanation.
 */

// Mock database with FIFO queue for multiple queries
jest.mock("@repo/database", () => {
  const queryResults: any[] = []

  const createQueryBuilder = () => {
    const builder: any = {
      from: jest.fn(() => builder),
      where: jest.fn(() => builder),
      orderBy: jest.fn(() => builder),
      limit: jest.fn(() => builder),
      offset: jest.fn(() => builder),
      set: jest.fn(() => builder),
      returning: jest.fn(() => builder),
      leftJoin: jest.fn(() => builder),
      groupBy: jest.fn(() => builder),
      then: (resolve: any, reject: any) => {
        const result = queryResults.shift() ?? []
        if (result instanceof Error) {
          return Promise.reject(result).catch(reject)
        }
        return Promise.resolve(result).then(resolve)
      },
      catch: (handler: any) => Promise.resolve([]).catch(handler),
    }
    return builder
  }

  return {
    db: {
      select: jest.fn(() => createQueryBuilder()),
      insert: jest.fn(() => createQueryBuilder()),
      update: jest.fn(() => createQueryBuilder()),
      delete: jest.fn(() => createQueryBuilder()),
    },
    {{name}}s: {
      id: "id",
      name: "name",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
    },
    eq: jest.fn((col, val) => ({ type: "eq", col, val })),
    and: jest.fn((...conds) => ({ type: "and", conds })),
    desc: jest.fn((col) => ({ type: "desc", col })),
    count: jest.fn(() => "count"),
    __queryResults__: queryResults,
  }
})

// Mock auth
const mockVerifyAdmin = jest.fn()
jest.mock("@/lib/auth", () => ({
  verifyAdmin: () => mockVerifyAdmin(),
}))

// Mock headers
jest.mock("next/headers", () => ({
  headers: jest.fn(() => new Headers()),
}))

// Mock cache
jest.mock("next/cache", () => ({
  revalidatePath: jest.fn(),
  revalidateTag: jest.fn(),
}))

// Import after mocking
import { db } from "@repo/database"
import { revalidatePath } from "next/cache"
import {
  get{{Name}}s,
  get{{Name}},
  create{{Name}},
  update{{Name}},
  delete{{Name}},
} from "../{{name}}"

// Get queue reference
const dbModule = require("@repo/database") as any
const queryResults = dbModule.__queryResults__ as any[]

// Helper functions
const queueQueryResult = (...results: any[]) => {
  results.forEach((r) => queryResults.push(r))
}
const clearQueryResults = () => {
  queryResults.length = 0
}

describe("{{Name}} Actions", () => {
  beforeEach(() => {
    jest.clearAllMocks()
    clearQueryResults()
    mockVerifyAdmin.mockResolvedValue({
      user: { id: "admin-1", email: "admin@example.com", role: "admin" },
    })
  })

  describe("get{{Name}}s", () => {
    it("should return paginated {{name}}s", async () => {
      const mock{{Name}}s = [
        { id: "1", name: "{{Name}} 1" },
        { id: "2", name: "{{Name}} 2" },
      ]

      // Queue: count query, then {{name}}s query
      queueQueryResult([{ count: 10 }], mock{{Name}}s)

      const result = await get{{Name}}s(1, 10)

      expect(result.data).toHaveLength(2)
      expect(result.total).toBe(10)
    })

    it("should throw error when not authenticated", async () => {
      mockVerifyAdmin.mockResolvedValueOnce(null)

      await expect(get{{Name}}s(1, 10)).rejects.toThrow("Unauthorized")
    })

    it("should propagate database error", async () => {
      queueQueryResult(new Error("Database connection lost"))

      await expect(get{{Name}}s(1, 10)).rejects.toThrow("Database connection lost")
    })
  })

  describe("get{{Name}}", () => {
    it("should return a single {{name}} by id", async () => {
      const mock{{Name}} = { id: "1", name: "{{Name}} 1" }

      queueQueryResult([mock{{Name}}])

      const result = await get{{Name}}("1")

      expect(result).toEqual(mock{{Name}})
    })

    it("should return null for non-existent {{name}}", async () => {
      queueQueryResult([])

      const result = await get{{Name}}("non-existent")

      expect(result).toBeNull()
    })
  })

  describe("create{{Name}}", () => {
    it("should create a {{name}} with valid data", async () => {
      const formData = new FormData()
      formData.append("name", "New {{Name}}")

      queueQueryResult([{ id: "new-id" }])

      const result = await create{{Name}}(formData)

      expect(result.success).toBe(true)
      expect(result.data?.id).toBe("new-id")
      expect(revalidatePath).toHaveBeenCalledWith("/{{name}}s")
    })

    it("should return error for missing name", async () => {
      const formData = new FormData()
      formData.append("name", "")

      const result = await create{{Name}}(formData)

      expect(result.success).toBe(false)
      expect(result.error).toBeDefined()
    })

    it("should return error when not authenticated", async () => {
      mockVerifyAdmin.mockResolvedValueOnce(null)

      const formData = new FormData()
      formData.append("name", "New {{Name}}")

      const result = await create{{Name}}(formData)

      expect(result.success).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })

    it("should handle database error", async () => {
      const formData = new FormData()
      formData.append("name", "New {{Name}}")

      queueQueryResult(new Error("Insert failed"))

      await expect(create{{Name}}(formData)).rejects.toThrow("Insert failed")
    })
  })

  describe("update{{Name}}", () => {
    it("should update a {{name}} with valid data", async () => {
      const formData = new FormData()
      formData.append("name", "Updated {{Name}}")

      queueQueryResult([{ id: "1" }])

      const result = await update{{Name}}("1", formData)

      expect(result.success).toBe(true)
      expect(revalidatePath).toHaveBeenCalled()
    })

    it("should return error for non-existent {{name}}", async () => {
      const formData = new FormData()
      formData.append("name", "Updated {{Name}}")

      queueQueryResult([])

      const result = await update{{Name}}("non-existent", formData)

      expect(result.success).toBe(false)
      expect(result.error).toContain("not found")
    })

    it("should return error when not authenticated", async () => {
      mockVerifyAdmin.mockResolvedValueOnce(null)

      const formData = new FormData()
      formData.append("name", "Updated {{Name}}")

      const result = await update{{Name}}("1", formData)

      expect(result.success).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })
  })

  describe("delete{{Name}}", () => {
    it("should delete a {{name}}", async () => {
      queueQueryResult([{ id: "1" }])

      const result = await delete{{Name}}("1")

      expect(result.success).toBe(true)
      expect(revalidatePath).toHaveBeenCalledWith("/{{name}}s")
    })

    it("should return error for non-existent {{name}}", async () => {
      queueQueryResult([])

      const result = await delete{{Name}}("non-existent")

      expect(result.success).toBe(false)
      expect(result.error).toContain("not found")
    })

    it("should return error when not authenticated", async () => {
      mockVerifyAdmin.mockResolvedValueOnce(null)

      const result = await delete{{Name}}("1")

      expect(result.success).toBe(false)
      expect(result.error).toBe("Unauthorized")
    })
  })
})
