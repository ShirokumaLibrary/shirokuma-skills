// lib/actions/{{name}}.ts
"use server"

import { revalidatePath } from "next/cache"
import { redirect } from "next/navigation"
import { z } from "zod"
import { db, {{name}}s, eq, desc, count } from "@repo/database"
import { verifyAdmin, verifyAdminMutation } from "@/lib/auth-utils"
import { checkRateLimit, RateLimiters } from "@/lib/rate-limit"

// ============================================================================
// Types
// ============================================================================

type ActionResult<T = void> =
  | { success: true; data?: T }
  | { success: false; error: string; code?: ActionErrorCode }

type ActionErrorCode =
  | "UNAUTHORIZED"
  | "CSRF_INVALID"
  | "VALIDATION_FAILED"
  | "NOT_FOUND"
  | "FORBIDDEN"
  | "DUPLICATE"
  | "RATE_LIMIT_EXCEEDED"
  | "INTERNAL_ERROR"

export type {{Name}} = {
  id: string
  name: string
  description: string | null
  authorId: string
  createdAt: Date
  updatedAt: Date
}

// ============================================================================
// Validation Schemas
// ============================================================================

const {{Name}}Schema = z.object({
  name: z.string().min(1, "Name is required").max(100, "Name must be 100 characters or less"),
  description: z.string().max(500, "Description must be 500 characters or less").nullable().optional(),
})

// ============================================================================
// Query Functions (use verifyAdmin - no CSRF needed)
// ============================================================================

const PAGE_SIZE = 20

/**
 * Get paginated {{name}}s
 */
export async function get{{Name}}s(page: number = 1) {
  await verifyAdmin()

  const offset = (page - 1) * PAGE_SIZE

  const [items, countResult] = await Promise.all([
    db
      .select()
      .from({{name}}s)
      .orderBy(desc({{name}}s.createdAt))
      .limit(PAGE_SIZE)
      .offset(offset),
    db.select({ count: count() }).from({{name}}s),
  ])

  const total = countResult[0]?.count ?? 0

  return {
    {{name}}s: items,
    pagination: {
      page,
      pageSize: PAGE_SIZE,
      total,
      totalPages: Math.ceil(total / PAGE_SIZE),
    },
  }
}

/**
 * Get a single {{name}} by ID
 */
export async function get{{Name}}(id: string): Promise<{{Name}} | null> {
  await verifyAdmin()

  const [result] = await db
    .select()
    .from({{name}}s)
    .where(eq({{name}}s.id, id))

  return result ?? null
}

// ============================================================================
// Mutation Functions (use verifyAdminMutation - includes CSRF)
// ============================================================================

/**
 * Create a new {{name}}
 */
export async function create{{Name}}(formData: FormData): Promise<ActionResult<{ id: string }> | void> {
  const userId = await verifyAdminMutation()

  const validated = {{Name}}Schema.safeParse({
    name: formData.get("name"),
    description: formData.get("description") || null,
  })

  if (!validated.success) {
    return { success: false, error: validated.error.errors[0].message, code: "VALIDATION_FAILED" }
  }

  // Duplicate check (optional - uncomment if needed)
  // const existing = await db.select().from({{name}}s).where(eq({{name}}s.name, validated.data.name)).limit(1)
  // if (existing.length > 0) {
  //   return { success: false, error: "Name already exists", code: "DUPLICATE" }
  // }

  const [result] = await db
    .insert({{name}}s)
    .values({
      name: validated.data.name,
      description: validated.data.description,
      authorId: userId,
    })
    .returning({ id: {{name}}s.id })

  revalidatePath("/{{name}}s")
  redirect("/{{name}}s")
}

/**
 * Update an existing {{name}}
 */
export async function update{{Name}}(id: string, formData: FormData): Promise<ActionResult | void> {
  const userId = await verifyAdminMutation()

  const validated = {{Name}}Schema.safeParse({
    name: formData.get("name"),
    description: formData.get("description") || null,
  })

  if (!validated.success) {
    return { success: false, error: validated.error.errors[0].message, code: "VALIDATION_FAILED" }
  }

  // Ownership check
  const existing = await db
    .select()
    .from({{name}}s)
    .where(eq({{name}}s.id, id))
    .limit(1)

  if (existing.length === 0) {
    return { success: false, error: "{{Name}} not found", code: "NOT_FOUND" }
  }

  if (existing[0].authorId !== userId) {
    return { success: false, error: "Not authorized to update this {{name}}", code: "FORBIDDEN" }
  }

  await db
    .update({{name}}s)
    .set({
      name: validated.data.name,
      description: validated.data.description,
      updatedAt: new Date(),
    })
    .where(eq({{name}}s.id, id))

  revalidatePath("/{{name}}s")
  revalidatePath(`/{{name}}s/${id}/edit`)
  redirect("/{{name}}s")
}

/**
 * Delete a {{name}}
 */
export async function delete{{Name}}(id: string): Promise<ActionResult> {
  const userId = await verifyAdminMutation()

  // Rate limiting
  const rateLimitKey = `delete-{{name}}:${userId}`
  const rateLimitResult = await checkRateLimit(rateLimitKey, RateLimiters.delete)

  if (!rateLimitResult.success) {
    const waitSeconds = Math.ceil((rateLimitResult.reset * 1000 - Date.now()) / 1000)
    return {
      success: false,
      error: `Rate limit exceeded. Try again in ${waitSeconds}s`,
      code: "RATE_LIMIT_EXCEEDED",
    }
  }

  // Ownership check
  const existing = await db
    .select()
    .from({{name}}s)
    .where(eq({{name}}s.id, id))
    .limit(1)

  if (existing.length === 0) {
    return { success: false, error: "{{Name}} not found", code: "NOT_FOUND" }
  }

  if (existing[0].authorId !== userId) {
    return { success: false, error: "Not authorized to delete this {{name}}", code: "FORBIDDEN" }
  }

  await db.delete({{name}}s).where(eq({{name}}s.id, id))

  revalidatePath("/{{name}}s")
  return { success: true }
}
