// __tests__/components/{{name}}-form.test.tsx
import { render, screen, fireEvent, waitFor } from "@testing-library/react"
import userEvent from "@testing-library/user-event"
import { NextIntlClientProvider } from "next-intl"
import { {{Name}}Form } from "@/components/{{name}}-form"
import { create{{Name}}, update{{Name}} } from "@/lib/actions/{{name}}"

// Mock actions
jest.mock("@/lib/actions/{{name}}", () => ({
  create{{Name}}: jest.fn(),
  update{{Name}}: jest.fn(),
}))

// Mock next/navigation
jest.mock("next/navigation", () => ({
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
  }),
}))

// Translation messages for testing
const messages = {
  common: {
    save: "Save",
    saving: "Saving...",
    cancel: "Cancel",
    delete: "Delete",
    edit: "Edit",
    create: "Create",
    saveFailed: "Failed to save",
  },
  {{name}}s: {
    title: "{{Name}} Management",
    new{{Name}}: "New {{Name}}",
    edit{{Name}}: "Edit {{Name}}",
    form: {
      info: "{{Name}} Info",
      name: "Name",
      namePlaceholder: "Enter {{name}} name",
      description: "Description",
      descriptionPlaceholder: "Enter description (optional)",
      saved: "Saved successfully",
    },
  },
}

// Helper to render with providers
function renderWithProviders(
  ui: React.ReactElement,
  { locale = "en" } = {}
) {
  return render(
    <NextIntlClientProvider locale={locale} messages={messages}>
      {ui}
    </NextIntlClientProvider>
  )
}

describe("{{Name}}Form", () => {
  const user = userEvent.setup()

  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe("Create mode", () => {
    it("should render form fields", () => {
      renderWithProviders(<{{Name}}Form />)

      expect(screen.getByLabelText("Name")).toBeInTheDocument()
      expect(screen.getByRole("button", { name: "Save" })).toBeInTheDocument()
    })

    it("should submit form with valid data", async () => {
      ;(create{{Name}} as jest.Mock).mockResolvedValue({ success: true, data: { id: "1" } })

      renderWithProviders(<{{Name}}Form />)

      await user.type(screen.getByLabelText("Name"), "Test {{Name}}")
      await user.click(screen.getByRole("button", { name: "Save" }))

      await waitFor(() => {
        expect(create{{Name}}).toHaveBeenCalled()
      })

      const formData = (create{{Name}} as jest.Mock).mock.calls[0][0]
      expect(formData.get("name")).toBe("Test {{Name}}")
    })

    it("should show loading state during submission", async () => {
      let resolvePromise: (value: any) => void
      const promise = new Promise((resolve) => {
        resolvePromise = resolve
      })
      ;(create{{Name}} as jest.Mock).mockReturnValue(promise)

      renderWithProviders(<{{Name}}Form />)

      await user.type(screen.getByLabelText("Name"), "Test {{Name}}")
      await user.click(screen.getByRole("button", { name: "Save" }))

      // Check loading state
      expect(screen.getByRole("button")).toBeDisabled()
      expect(screen.getByText("Saving...")).toBeInTheDocument()

      // Resolve the promise
      resolvePromise!({ success: true })

      await waitFor(() => {
        expect(screen.getByRole("button")).not.toBeDisabled()
      })
    })

    it("should display error message on failure", async () => {
      ;(create{{Name}} as jest.Mock).mockResolvedValue({
        success: false,
        error: "Name already exists",
      })

      renderWithProviders(<{{Name}}Form />)

      await user.type(screen.getByLabelText("Name"), "Duplicate Name")
      await user.click(screen.getByRole("button", { name: "Save" }))

      await waitFor(() => {
        expect(screen.getByText("Name already exists")).toBeInTheDocument()
      })
    })

    it("should show success message on successful save", async () => {
      ;(create{{Name}} as jest.Mock).mockResolvedValue({ success: true })

      renderWithProviders(<{{Name}}Form />)

      await user.type(screen.getByLabelText("Name"), "Test {{Name}}")
      await user.click(screen.getByRole("button", { name: "Save" }))

      await waitFor(() => {
        expect(screen.getByText("Saved successfully")).toBeInTheDocument()
      })
    })
  })

  describe("Edit mode", () => {
    const initialData = {
      id: "1",
      name: "Existing {{Name}}",
      description: "Existing description",
    }

    it("should populate form with initial data", () => {
      renderWithProviders(<{{Name}}Form initialData={initialData} />)

      expect(screen.getByLabelText("Name")).toHaveValue("Existing {{Name}}")
    })

    it("should call update action on submit", async () => {
      ;(update{{Name}} as jest.Mock).mockResolvedValue({ success: true })

      renderWithProviders(<{{Name}}Form initialData={initialData} />)

      await user.clear(screen.getByLabelText("Name"))
      await user.type(screen.getByLabelText("Name"), "Updated {{Name}}")
      await user.click(screen.getByRole("button", { name: "Save" }))

      await waitFor(() => {
        expect(update{{Name}}).toHaveBeenCalled()
      })

      const [id, formData] = (update{{Name}} as jest.Mock).mock.calls[0]
      expect(id).toBe("1")
      expect(formData.get("name")).toBe("Updated {{Name}}")
    })
  })

  describe("Validation", () => {
    it("should not submit when name is empty", async () => {
      renderWithProviders(<{{Name}}Form />)

      // Name input has required attribute
      const nameInput = screen.getByLabelText("Name")
      expect(nameInput).toHaveAttribute("required")

      // Try to submit without filling name
      await user.click(screen.getByRole("button", { name: "Save" }))

      // create{{Name}} should not be called
      expect(create{{Name}}).not.toHaveBeenCalled()
    })
  })

  describe("Accessibility", () => {
    it("should have accessible labels", () => {
      renderWithProviders(<{{Name}}Form />)

      expect(screen.getByLabelText("Name")).toBeInTheDocument()
    })

    it("should associate error messages with inputs", async () => {
      ;(create{{Name}} as jest.Mock).mockResolvedValue({
        success: false,
        error: "Validation error",
      })

      renderWithProviders(<{{Name}}Form />)

      await user.type(screen.getByLabelText("Name"), "Test")
      await user.click(screen.getByRole("button", { name: "Save" }))

      await waitFor(() => {
        const errorMessage = screen.getByRole("alert")
        expect(errorMessage).toBeInTheDocument()
      })
    })
  })

  describe("i18n", () => {
    it("should render in Japanese", () => {
      const jaMessages = {
        common: {
          save: "保存",
          saving: "保存中...",
        },
        {{name}}s: {
          form: {
            info: "{{Name}}情報",
            name: "名前",
            namePlaceholder: "{{name}}名を入力",
          },
        },
      }

      render(
        <NextIntlClientProvider locale="ja" messages={jaMessages}>
          <{{Name}}Form />
        </NextIntlClientProvider>
      )

      expect(screen.getByLabelText("名前")).toBeInTheDocument()
      expect(screen.getByRole("button", { name: "保存" })).toBeInTheDocument()
    })
  })
})
